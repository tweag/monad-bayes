

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Developer Guide &mdash; monad-bayes  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="monad-bayes  documentation" href="index.html"/>
        <link rel="prev" title="User Guide" href="probprog.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> monad-bayes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="probprog.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Developer Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-core-typeclasses">The core typeclasses</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#monadsample">MonadSample</a></li>
<li class="toctree-l3"><a class="reference internal" href="#monadcond">MonadCond</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#inference-transformers">Inference transformers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#enumerator">Enumerator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#samplerio">SamplerIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#weighted-m">Weighted m</a></li>
<li class="toctree-l3"><a class="reference internal" href="#population">Population</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sequential">Sequential</a></li>
<li class="toctree-l3"><a class="reference internal" href="#freesampler">FreeSampler</a></li>
<li class="toctree-l3"><a class="reference internal" href="#traced">Traced</a></li>
<li class="toctree-l3"><a class="reference internal" href="#integrator">Integrator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#inference-methods-under-the-hood">Inference methods under the hood</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#exact-inference">Exact inference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quadrature">Quadrature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#independent-forward-sampling">Independent forward sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#independent-weighted-sampling">Independent weighted sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#metropolis-hastings-mcmc">Metropolis Hastings MCMC</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sequential-importance-sampling">Sequential Importance Sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sequential-monte-carlo">Sequential Monte Carlo</a></li>
<li class="toctree-l3"><a class="reference internal" href="#particle-marginal-metropolis-hastings">Particle Marginal Metropolis Hastings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#resample-move-sequential-monte-carlo">Resample-Move Sequential Monte Carlo</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sequential-monte-carlo-squared-smc-2">Sequential Monte Carlo squared ($SMC^2$)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">monad-bayes</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Developer Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/usage.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="developer-guide">
<h1>Developer Guide<a class="headerlink" href="#developer-guide" title="Permalink to this headline">¶</a></h1>
<p>This document assumes the reader is familiar with:</p>
<ul class="simple">
<li><p>the basics of Bayesian probability theory</p></li>
<li><p>basic Haskell (the syntax, the type system, do-notation, monad transformers)</p></li>
<li><p>how to specify distributions in monad-bayes (see the <a class="reference internal" href="probprog.html"><span class="doc std std-doc">docs</span></a>)</p></li>
</ul>
<p>That’s enough to understand the core ideas, but for the more advanced content, you’ll also want to feel comfortable enough with Haskell’s type system that free monads, free monad transformers, and coroutines aren’t a barrier to entry. And of course, to understand how inference methods like MCMC and SMC are implemented, it doesn’t hurt to understand how they work in a statistical sense.</p>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>monad-bayes is the codebase accompanying the theory of probabilistic programming described in <a class="reference external" href="https://www.denotational.co.uk/publications/scibior-kammar-ghahramani-funcitonal-programming-for-modular-bayesian-inference.pdf">this paper</a>.</p>
</section>
<section id="the-core-typeclasses">
<h2>The core typeclasses<a class="headerlink" href="#the-core-typeclasses" title="Permalink to this headline">¶</a></h2>
<p>The library relies on two core typeclasses <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> and <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code>. <code class="docutils literal notranslate"><span class="pre">MonadInfer</span></code> is simply the union of the two, that is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">MonadSample</span> <span class="n">m</span><span class="p">,</span> <span class="kt">MonadCond</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadInfer</span> <span class="n">m</span>
</pre></div>
</div>
<p>You can find these in <code class="docutils literal notranslate"><span class="pre">Control.Monad.Bayes.Class</span></code>.</p>
<section id="monadsample">
<h3>MonadSample<a class="headerlink" href="#monadsample" title="Permalink to this headline">¶</a></h3>
<p>Here is <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadSample</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">random</span> <span class="ow">::</span> <span class="n">m</span> <span class="kt">Double</span>
</pre></div>
</div>
<p>This one method, <code class="docutils literal notranslate"><span class="pre">random</span></code>, represents a uniform distribution over $[0,1]$. (<code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> actually has a few other distributions, but that’s not essential.)</p>
<p>What comes next is clever: you can define any other distribution you like in terms of <code class="docutils literal notranslate"><span class="pre">random</span></code>. As an example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bernoulli</span> <span class="ow">::</span> <span class="kt">MonadSample</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="kt">Bool</span>
<span class="nf">bernoulli</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="n">random</span>
</pre></div>
</div>
<p>That one is pretty simple. As a more complex example, here’s how a normal distribution is defined:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">normal</span> <span class="n">m</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">quantile</span> <span class="p">(</span><span class="n">normalDistr</span> <span class="n">m</span> <span class="n">s</span><span class="p">))</span> <span class="n">random</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">normalDistr</span></code> comes from a separate library <code class="docutils literal notranslate"><span class="pre">Statistics.Distribution.Normal</span></code> and <code class="docutils literal notranslate"><span class="pre">quantile</span> <span class="pre">(normalDistr</span> <span class="pre">m</span> <span class="pre">s)</span> <span class="pre">::</span> <span class="pre">Double</span> <span class="pre">-&gt;</span> <span class="pre">Double</span></code> is the inverse CDF of the normal, a deterministic function.</p>
<p>Again, to emphasize: <strong>all of our randomness can be reduced to draws from a uniform distribution over the interval $[0,1]$</strong>.</p>
<p>So we now have a way of constructing distributions in a monadic fashion. As a simple example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">example</span> <span class="ow">::</span> <span class="kt">MonadSample</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="kt">Double</span>
<span class="nf">example</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">random</span>
    <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">uniform</span> <span class="mi">0</span> <span class="n">x</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mf">1.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Think of this as the procedure of first sampling uniformly from $[0,1]$, then from $[0,x]$, and then returning the Boolean $x + y &gt; 1.5$. More precisely, this is the <strong>marginal</strong> probability of $x + y &gt; 1.5$.</p>
<p><strong>Technical note</strong>: <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> actually contains a number of other distributions beyond <code class="docutils literal notranslate"><span class="pre">random</span></code>, which by default are defined in terms of <code class="docutils literal notranslate"><span class="pre">random</span></code>, but allow for different definitions when desired. For example, <code class="docutils literal notranslate"><span class="pre">SamplerST</span></code> (an instance of <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> in Control.Monad.Sampler) defines <code class="docutils literal notranslate"><span class="pre">normal</span></code> and other distributions independently of <code class="docutils literal notranslate"><span class="pre">random</span></code>.</p>
<!-- Inference is TODO
 `example1`, of type `MonadSample m => m Double`, and turn it into something we can actually see. Like samples. Or a parameter of a Bernoulli distribution. Those are problems for the next section, which is concerned with *interpreting* `MonadSample` as something more concrete, namely an inference algorithm. -->
<!-- The core philosophy of monad-bayes is that we specify distributions (probabilistic programs, that is) in this abstract monadic typeclass, and then cash it out in a variety of concrete ways which allow for convenient inference algorithms. -->
</section>
<section id="monadcond">
<h3>MonadCond<a class="headerlink" href="#monadcond" title="Permalink to this headline">¶</a></h3>
<p>Here’s <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadCond</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">score</span> <span class="ow">::</span> <span class="kt">Log</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Log</span> <span class="pre">Double</span></code> is defined in <code class="docutils literal notranslate"><span class="pre">Numeric.Log</span></code>, and is a wrapper for <code class="docutils literal notranslate"><span class="pre">Double</span></code>s which does multiplication in log-space. It comes with <code class="docutils literal notranslate"><span class="pre">Exp</span> <span class="pre">::</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Log</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">ln</span> <span class="pre">::</span> <span class="pre">Log</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>. This is because we don’t want numerical problems when multiplying tiny probabilities, and we want a hassle free typesafe separation of doubles and log-doubles.</p>
<!-- `score` is less intuitive than `random`. It will become clearer when we discuss more concrete interpretations of `MonadCond`, but what's important to know here is that it is used to allow us to do the Bayesian part of probability, as exemplified by the following probabilistic program:  -->
</section>
</section>
<section id="inference-transformers">
<h2>Inference transformers<a class="headerlink" href="#inference-transformers" title="Permalink to this headline">¶</a></h2>
<p>Now core idea of monad-bayes is that various monads will be made to be instances of <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code>, <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code> or both (i.e. an instance of <code class="docutils literal notranslate"><span class="pre">MonadInfer</span></code>), and different inference algorithms will be written using these instances. This separates the specification of the model (which happens abstractly in <code class="docutils literal notranslate"><span class="pre">MonadInfer</span></code>) from the inference algorithm, which takes place in on of the concrete instances. The clever part of monad-bayes is that it allows this instances to be constructed in a modular way, using monad transformers. In the paper, these are termed <em>inference transformers</em> to emphasize that it doesn’t really matter whether they satisfy the monad laws.</p>
<p>For example, to run weighted rejection sampling on a probabilistic program <code class="docutils literal notranslate"><span class="pre">p</span></code>, we can write <code class="docutils literal notranslate"><span class="pre">(sampleIO</span> <span class="pre">.</span> <span class="pre">runWeighted)</span> <span class="pre">p</span></code>. Here, <code class="docutils literal notranslate"><span class="pre">(sampleIO</span> <span class="pre">.</span> <span class="pre">runWeighted)</span> <span class="pre">::</span> <span class="pre">Weighted</span> <span class="pre">SamplerIO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a</span></code>. So <code class="docutils literal notranslate"><span class="pre">p</span></code> gets understood as being of type <code class="docutils literal notranslate"><span class="pre">Weighted</span> <span class="pre">SamplerIO</span></code>, a type we’ll encounter soon.</p>
<p>Some of these transformers are easy to understand (like <code class="docutils literal notranslate"><span class="pre">StateT</span> <span class="pre">Double</span></code>, while others (like the Church transformed Free monad transformer) lie on the more advanced side of things. The following tour of these types goes from easy to hard.</p>
<section id="enumerator">
<h3>Enumerator<a class="headerlink" href="#enumerator" title="Permalink to this headline">¶</a></h3>
<p>Summary of key info:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Enumerator</span> <span class="pre">::</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadSample</span> <span class="pre">Enumerator</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadCond</span> <span class="pre">Enumerator</span></code></p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Enumerator</span></code> is in <code class="docutils literal notranslate"><span class="pre">Control.Monad.Bayes.Enumerator</span></code>, defined as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Enumerator</span> <span class="n">a</span> <span class="ow">=</span> 
    <span class="kt">Enumerator</span> <span class="p">(</span><span class="kt">WriterT</span> <span class="p">(</span><span class="kt">Product</span> <span class="p">(</span><span class="kt">Log</span> <span class="kt">Double</span><span class="p">))</span> <span class="kt">[]</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>This merits a little unpacking. First, <code class="docutils literal notranslate"><span class="pre">Product</span></code> is a wrapper from <a class="reference external" href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Monoid.html">Data.Monoid</a> which makes the semigroup operator for numbers be multiplication, so that:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Product</span> <span class="mi">2</span> <span class="o">&lt;&gt;</span> <span class="kt">Product</span> <span class="mi">3</span> <span class="o">==</span> <span class="kt">Product</span> <span class="mi">6</span><span class="p">`</span>
</pre></div>
</div>
<p>Unpacking the definition of <code class="docutils literal notranslate"><span class="pre">Enumerator</span> <span class="pre">a</span></code>, it is isomorphic to:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="kt">Product</span> <span class="p">(</span><span class="kt">Log</span> <span class="kt">Double</span><span class="p">)))]</span>
</pre></div>
</div>
<p>So, a value of type <code class="docutils literal notranslate"><span class="pre">Enumerator</span> <span class="pre">Bool</span></code>, for instance, is a list of pairs of booleans along with a double, like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="kt">False</span><span class="p">,</span><span class="mf">0.8914</span><span class="p">),(</span><span class="kt">True</span><span class="p">,</span><span class="mf">0.1086</span><span class="p">)]</span>
</pre></div>
</div>
<p>Also in <code class="docutils literal notranslate"><span class="pre">Control.Monad.Bayes.Enumerator</span></code> is a function <code class="docutils literal notranslate"><span class="pre">enumerate</span></code>, which has type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">enumerate</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Enumerator</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)]</span>
</pre></div>
</div>
<p>We can write <code class="docutils literal notranslate"><span class="pre">enumerate</span> <span class="pre">sprinkler</span></code>. Why is this well typed? The idea is that <code class="docutils literal notranslate"><span class="pre">sprinkler</span></code> has type <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">m.</span> <span class="pre">MonadInfer</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">Bool</span></code>, and we <em>instantiate</em> that <code class="docutils literal notranslate"><span class="pre">m</span></code> as <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code>.</p>
<p>But for this to be well-typed, we need <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code> to be an instance of <code class="docutils literal notranslate"><span class="pre">MonadInfer</span></code>. For that, we need <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code> to be a <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code>, and a <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code>. For that, we need it to be a <code class="docutils literal notranslate"><span class="pre">Monad</span></code>, and in turn, a <code class="docutils literal notranslate"><span class="pre">Functor</span></code>. In understanding these instance definition, we’ll understand what what <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code> is doing for us.</p>
<p><code class="docutils literal notranslate"><span class="pre">Enumerator</span></code> is a monad automatically, because <code class="docutils literal notranslate"><span class="pre">WriterT</span> <span class="pre">a</span> <span class="pre">m</span></code> is a monad for <code class="docutils literal notranslate"><span class="pre">a</span></code> a monoid and <code class="docutils literal notranslate"><span class="pre">m</span></code> a monad. As needed, <code class="docutils literal notranslate"><span class="pre">[]</span></code> is a monad and <code class="docutils literal notranslate"><span class="pre">Log</span> <span class="pre">Double</span></code> is a monoid. But what does that monad actually <strong>do</strong>?</p>
<p>For instance, if I have a weighted list <code class="docutils literal notranslate"><span class="pre">l</span></code> like <code class="docutils literal notranslate"><span class="pre">[(False,0.8914),(True,0.1086)]</span></code> and a function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">::</span> <span class="pre">Bool</span> <span class="pre">-&gt;</span> <span class="pre">Enumerator</span> <span class="pre">a</span></code>, what is <code class="docutils literal notranslate"><span class="pre">l</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></code>? It takes each element in <code class="docutils literal notranslate"><span class="pre">l</span></code>, and passes it through <code class="docutils literal notranslate"><span class="pre">f</span></code>, to obtain a weighted list of weighted lists. Then it flattens it, by including each element in the inner lists in the resulting list, with the weight of the list multiplied by the weight of the element. As for <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">x</span></code>, it gives the singleton list containing the pair of <code class="docutils literal notranslate"><span class="pre">x</span></code> and the unit of the product monoid, i.e. <code class="docutils literal notranslate"><span class="pre">[(x,</span> <span class="pre">1.0)]</span></code>.</p>
<p>This is the essence of propagating probability forward.</p>
<!-- This is of course a representation of a discrete distribution, and as we might expect, `Enumerator` is only going to be useful when we are dealing with discrete distributions. -->
<p>What remains is to define the <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> and <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code> instances:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">MonadSample</span> <span class="kt">Enumerator</span> <span class="kr">where</span>
  <span class="n">random</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;Infinitely supported random variables not supported in Enumerator&quot;</span>
  <span class="n">bernoulli</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">fromList</span> <span class="p">[(</span><span class="kt">True</span><span class="p">,</span> <span class="p">(</span><span class="kt">Exp</span> <span class="o">.</span> <span class="n">log</span><span class="p">)</span> <span class="n">p</span><span class="p">),</span> <span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="p">(</span><span class="kt">Exp</span> <span class="o">.</span> <span class="n">log</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">))]</span>
</pre></div>
</div>
<p>The first thing to notice is that <code class="docutils literal notranslate"><span class="pre">random</span></code> is actually not defined for <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code>, and consequently, you can’t handle any continuous distributions. This makes sense, because you can’t represent continuous distributions (whose support is uncountably infinite) as a list of samples.</p>
<p>So really <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code> isn’t very general purpose. It’s best understood as a didactic tool, rather than a real world inference algorithm.</p>
<p>But it can handle discrete distributions. It does this via <code class="docutils literal notranslate"><span class="pre">bernoulli</span></code> (as well as <code class="docutils literal notranslate"><span class="pre">categorical</span></code>, which I’ve omitted). <code class="docutils literal notranslate"><span class="pre">bernoulli</span> <span class="pre">p</span></code> constructs the weighted list corresponding to a <code class="docutils literal notranslate"><span class="pre">bernoulli</span></code> distribution with parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>And the <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code> instance:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">MonadCond</span> <span class="kt">Enumerator</span> <span class="kr">where</span>
  <span class="n">score</span> <span class="n">w</span> <span class="ow">=</span> <span class="n">fromList</span> <span class="p">[(</span><span class="nb">()</span><span class="p">,</span> <span class="n">w</span><span class="p">)]</span>
</pre></div>
</div>
<p>Finally, <code class="docutils literal notranslate"><span class="pre">enumerate</span></code> simply unwraps <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code> to get a list of pairs of values and their weights, and then normalizes them into probabilities. It orders the list, which is why <code class="docutils literal notranslate"><span class="pre">enumerate</span></code> requires an <code class="docutils literal notranslate"><span class="pre">Ord</span></code> instance.</p>
<p>To see how this all works together, consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">example</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">bernoulli</span> <span class="mf">0.5</span>
  <span class="n">condition</span> <span class="n">x</span>
  <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>From the way the <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> instance for <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code> is defined, <code class="docutils literal notranslate"><span class="pre">bernoulli</span> <span class="pre">0.5</span></code> is a list of two pairs: <code class="docutils literal notranslate"><span class="pre">[(True,</span> <span class="pre">0.5),</span> <span class="pre">(False,</span> <span class="pre">0.5)]</span></code>. Using the <code class="docutils literal notranslate"><span class="pre">Monad</span></code> instance, the next line multiplies each of the masses by a number (<code class="docutils literal notranslate"><span class="pre">0</span></code> for <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code> for <code class="docutils literal notranslate"><span class="pre">False</span></code>). The final line multiplies both by <code class="docutils literal notranslate"><span class="pre">1.0</span></code>. And then <code class="docutils literal notranslate"><span class="pre">enumerate</span></code> normalizes the result. So the ensuing distribution from <code class="docutils literal notranslate"><span class="pre">enumerate</span> <span class="pre">example</span></code> is <code class="docutils literal notranslate"><span class="pre">{True</span> <span class="pre">:</span> <span class="pre">1.0}</span></code>.</p>
<!-- ```haskell
example2 = do
    x <- bernoulli 0.5
    y <- bernoulli $ if x then 0.6 else 0.5
    return (y && x)
``` -->
</section>
<section id="samplerio">
<h3>SamplerIO<a class="headerlink" href="#samplerio" title="Permalink to this headline">¶</a></h3>
<p>Summary of key info on <code class="docutils literal notranslate"><span class="pre">SamplerIO</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SamplerIO</span> <span class="pre">::</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadSample</span> <span class="pre">SamplerIO</span></code></p></li>
<li><p><strong>No</strong> instance for <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code></p></li>
</ul>
<p>Summary of key info on <code class="docutils literal notranslate"><span class="pre">SamplerST</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SamplerST</span> <span class="pre">::</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadSample</span> <span class="pre">SamplerST</span></code></p></li>
<li><p><strong>No</strong> instance for <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code></p></li>
</ul>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">SamplerIO</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">SamplerIO</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="kt">GenIO</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>There are various different implementations of samplers that you could write, depending on the statistical details of how you want to sample. Two are in monad-bayes (SamplerIO and SamplerST).</p>
<p>As the names suggest, these instances of <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> instantiate an abstract distribution as a sampling procedure. We have</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">MonadSample</span> <span class="kt">SamplerST</span> <span class="kr">where</span>
  <span class="n">random</span> <span class="ow">=</span> <span class="n">fromMWC</span> <span class="kt">System</span><span class="o">.</span><span class="kt">Random</span><span class="o">.</span><span class="kt">MWC</span><span class="o">.</span><span class="n">uniform</span>
  <span class="n">uniform</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">fromMWC</span> <span class="o">$</span> <span class="n">uniformR</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">normal</span> <span class="n">m</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">fromMWC</span> <span class="o">$</span> <span class="kt">MWC</span><span class="o">.</span><span class="n">normal</span> <span class="n">m</span> <span class="n">s</span>
  <span class="n">gamma</span> <span class="n">shape</span> <span class="n">scale</span> <span class="ow">=</span> <span class="n">fromMWC</span> <span class="o">$</span> <span class="kt">MWC</span><span class="o">.</span><span class="n">gamma</span> <span class="n">shape</span> <span class="n">scale</span>
  <span class="n">beta</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">fromMWC</span> <span class="o">$</span> <span class="kt">MWC</span><span class="o">.</span><span class="n">beta</span> <span class="n">a</span> <span class="n">b</span>
  <span class="n">bernoulli</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">fromMWC</span> <span class="o">$</span> <span class="kt">MWC</span><span class="o">.</span><span class="n">bernoulli</span> <span class="n">p</span>
  <span class="n">categorical</span> <span class="n">ps</span> <span class="ow">=</span> <span class="n">fromMWC</span> <span class="o">$</span> <span class="kt">MWC</span><span class="o">.</span><span class="n">categorical</span> <span class="n">ps</span>
  <span class="n">geometric</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">fromMWC</span> <span class="o">$</span> <span class="kt">MWC</span><span class="o">.</span><span class="n">geometric0</span> <span class="n">p</span>
  
</pre></div>
</div>
<p>Were the lines from <code class="docutils literal notranslate"><span class="pre">uniform</span></code> to <code class="docutils literal notranslate"><span class="pre">geometric</span></code> commented out, they would be instantiated with the defaults defined in terms of <code class="docutils literal notranslate"><span class="pre">random</span></code> in the <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> class. The reason they are not is that there are more statistically efficient ways to sample.</p>
<p>We can unpack values from <code class="docutils literal notranslate"><span class="pre">SamplerIO</span> <span class="pre">a</span></code> using <code class="docutils literal notranslate"><span class="pre">sampleIO</span> <span class="pre">::</span> <span class="pre">SamperIO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a</span></code> and from <code class="docutils literal notranslate"><span class="pre">SamplerST</span></code> using <code class="docutils literal notranslate"><span class="pre">sampleSTfixed</span></code>.</p>
<!-- The idea is that we have a function `sampleIO :: SamperIO a -> IO a`, then: -->
<p>So for example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">print</span> <span class="o">=&lt;&lt;</span> <span class="n">sampleIO</span> <span class="n">random</span>
</pre></div>
</div>
<p>will print a sample from <code class="docutils literal notranslate"><span class="pre">random</span></code>. Similarly for other distributions.</p>
<p>But note that <code class="docutils literal notranslate"><span class="pre">SamplerIO</span></code> and <code class="docutils literal notranslate"><span class="pre">SamplerST</span></code> only have <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> instances. This means that <code class="docutils literal notranslate"><span class="pre">sampleIO</span> <span class="pre">sprinkler</span></code> does not type check and gives the type error:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">MonadInfer</span> <span class="kt">SamplerIO</span><span class="p">)</span>
</pre></div>
</div>
<p>This is to be expected. <code class="docutils literal notranslate"><span class="pre">SamplerIO</span></code> and <code class="docutils literal notranslate"><span class="pre">SamplerST</span></code> have no instance for <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code>.</p>
</section>
<section id="weighted-m">
<h3>Weighted m<a class="headerlink" href="#weighted-m" title="Permalink to this headline">¶</a></h3>
<p>Summary of key info on <code class="docutils literal notranslate"><span class="pre">Weighted</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Weighted</span> <span class="pre">::</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span> <span class="pre">-&gt;</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadSample</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">MonadInfer</span> <span class="pre">(Weighted</span> <span class="pre">m)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadCond</span> <span class="pre">(Weighted</span> <span class="pre">m)</span></code></p></li>
</ul>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Weighted</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Weighted</span> <span class="p">(</span><span class="kt">StateT</span> <span class="p">(</span><span class="kt">Log</span> <span class="kt">Double</span><span class="p">)</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>A <strong>key</strong> difference to <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code> and <code class="docutils literal notranslate"><span class="pre">SamplerIO</span></code> is the <strong>kind</strong> of <code class="docutils literal notranslate"><span class="pre">Weighted</span></code>: it takes a type <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">::</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code> as an argument.</p>
<!-- It takes not just a type `a :: Type` as argument, but also a type `m :: Type -> Type`. -->
<p><code class="docutils literal notranslate"><span class="pre">Weighted</span> <span class="pre">m</span></code> is isomorphic to:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Log</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span> <span class="kt">Double</span><span class="p">)</span>
</pre></div>
</div>
<p>Some intuition for what this means comes from the <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code> instance:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadCond</span> <span class="p">(</span><span class="kt">Weighted</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">score</span> <span class="n">w</span> <span class="ow">=</span> <span class="kt">Weighted</span> <span class="p">(</span><span class="n">modify</span> <span class="p">(</span><span class="o">*</span> <span class="n">w</span><span class="p">))</span>
</pre></div>
</div>
<p>So if we write:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">example</span> <span class="ow">::</span> <span class="kt">MonadSample</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Weighted</span> <span class="n">m</span> <span class="kt">Bool</span>
<span class="nf">example</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">bernoulli</span> <span class="mf">0.5</span>
    <span class="n">score</span> <span class="p">(</span><span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>then the result is that first, we draw a sample from a Bernoulli distribution from the <strong>underlying</strong> distribution <code class="docutils literal notranslate"><span class="pre">m</span></code>, and then multiply the state (which is a <code class="docutils literal notranslate"><span class="pre">Log</span> <span class="pre">Double</span></code>) by a number which depends on that sample. For convenience, we write <code class="docutils literal notranslate"><span class="pre">condition</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">score</span> <span class="pre">(if</span> <span class="pre">b</span> <span class="pre">then</span> <span class="pre">1</span> <span class="pre">else</span> <span class="pre">0)</span></code>.</p>
<p>To unpack from <code class="docutils literal notranslate"><span class="pre">Weighted</span> <span class="pre">m</span> <span class="pre">a</span></code>, we use:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">runWeighted</span> <span class="ow">::</span> <span class="kt">Weighted</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span> <span class="kt">Double</span><span class="p">)</span>
<span class="nf">runWeighted</span> <span class="p">(</span><span class="kt">Weighted</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="n">runStateT</span> <span class="n">m</span> <span class="mi">1</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Weighted</span> <span class="pre">m</span></code> is not an instance of <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code>, but only as instance of <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code> (and that, only when <code class="docutils literal notranslate"><span class="pre">m</span></code> is an instance of <code class="docutils literal notranslate"><span class="pre">Monad</span></code>). However, since <code class="docutils literal notranslate"><span class="pre">StateT</span></code> is a monad transformer, there is a function <code class="docutils literal notranslate"><span class="pre">lift</span> <span class="pre">::</span> <span class="pre">m</span> <span class="pre">Double</span> <span class="pre">-&gt;</span> <span class="pre">Weighted</span> <span class="pre">m</span> <span class="pre">Double</span></code>.</p>
<p>So if we take a <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> instance like <code class="docutils literal notranslate"><span class="pre">SamplerIO</span></code>, then <code class="docutils literal notranslate"><span class="pre">Weighted</span> <span class="pre">SamplerIO</span></code> is an instance of both <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> and <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code>. Which means it is an instance of <code class="docutils literal notranslate"><span class="pre">MonadInfer</span></code>.</p>
<p>So we can successfully write <code class="docutils literal notranslate"><span class="pre">(sampleIO</span> <span class="pre">.</span> <span class="pre">runWeighted)</span> <span class="pre">sprinkler</span></code> and get a program of type <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">(Bool,</span> <span class="pre">Log</span> <span class="pre">Double)</span></code>. When run, this will draw a sample from <code class="docutils literal notranslate"><span class="pre">sprinkler</span></code> along with an <strong>unnormalized</strong> density for that sample.</p>
<p>It’s worth stopping here to remark on what’s going on. What has happened is that the <code class="docutils literal notranslate"><span class="pre">m</span></code> in <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">m.</span> <span class="pre">MonadInfer</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">Bool</span></code> has been <em>instantiated</em> as <code class="docutils literal notranslate"><span class="pre">Weighted</span> <span class="pre">SamplerIO</span></code>. This is an example of how the interpreters for inference can be composed in modular ways.</p>
<p>Finally, there’s a function</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hoist</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="n">m</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Weighted</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Weighted</span> <span class="n">n</span> <span class="n">a</span>
</pre></div>
</div>
<p>This takes a natural transformation <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">~&gt;</span> <span class="pre">n</span></code> and lifts it into a natural transformation <code class="docutils literal notranslate"><span class="pre">Weighted</span> <span class="pre">m</span> <span class="pre">~&gt;</span> <span class="pre">Weighted</span> <span class="pre">n</span></code>. Most of the inference transformers have an analogous <code class="docutils literal notranslate"><span class="pre">hoist</span></code> function.</p>
<!-- `Weighted` and `SamplerIO` are on the simpler side, but illustrate the key principles of monad-bayes, namely:

**composable stack of inference transformers, implemented as instances of `MonadSample` and `MonadCond` typeclasses.**

In a similar vein, `Population` and `Sequential` go together to handle Sequential Monte Carlo (SMC), and `Traced` is associated with Markov Chain Monte Carlo (MCMC). -->
</section>
<section id="population">
<h3>Population<a class="headerlink" href="#population" title="Permalink to this headline">¶</a></h3>
<p>Summary of key info on <code class="docutils literal notranslate"><span class="pre">Population</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Population</span> <span class="pre">::</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span> <span class="pre">-&gt;</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadSample</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">instance</span> <span class="pre">MonadSample</span> <span class="pre">(Population</span> <span class="pre">m)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadCond</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">instance</span> <span class="pre">MonadCond</span> <span class="pre">(Population</span> <span class="pre">m)</span></code></p></li>
</ul>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Population</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Population</span> <span class="p">(</span><span class="kt">Weighted</span> <span class="p">(</span><span class="kt">ListT</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>So:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Population</span> <span class="n">m</span> <span class="n">a</span> <span class="o">~</span> <span class="n">m</span> <span class="p">[</span><span class="kt">Log</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span> <span class="kt">Double</span><span class="p">)]</span>
</pre></div>
</div>
<p>Note that while <code class="docutils literal notranslate"><span class="pre">ListT</span></code> isn’t in general a valid monad transformer, we’re not requiring it to be one here.</p>
<p><code class="docutils literal notranslate"><span class="pre">Population</span></code> is used to represent a collection of particles (in the statistical sense), along with their weights.</p>
<p>There are several useful functions associated with it:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">spawn</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Population</span> <span class="n">m</span> <span class="nb">()</span>
<span class="nf">spawn</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">fromWeightedList</span> <span class="o">$</span> <span class="n">pure</span> <span class="o">$</span> <span class="n">replicate</span> <span class="n">n</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">fromIntegral</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">spawn</span></code> spawns new particles. As an example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">enumerate</span> <span class="o">$</span> <span class="n">runPopulation</span> <span class="p">(</span><span class="n">spawn</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>gives</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[([(</span><span class="nb">()</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),(</span><span class="nb">()</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)],</span><span class="mf">1.0</span><span class="p">)]</span>
</pre></div>
</div>
<p>Observe how here we have interpreted <code class="docutils literal notranslate"><span class="pre">(spawn</span> <span class="pre">2)</span></code> as of type <code class="docutils literal notranslate"><span class="pre">Population</span> <span class="pre">Enumerator</span> <span class="pre">()</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">resampleGeneric</span></code> takes a function to probabilistically select a set of indices from a vector, and makes a new population by selecting those indices.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">resampleGeneric</span> <span class="ow">::</span>
  <span class="kt">MonadSample</span> <span class="n">m</span> <span class="ow">=&gt;</span>
    <span class="p">(</span><span class="kt">V</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="ow">-&gt;</span>
    <span class="kt">Population</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span>
    <span class="kt">Population</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pushEvidence</span></code>, to quote the API docs, “normalizes the weights in the population, while at the same time incorporating the sum of the weights as a score in m.”</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pushEvidence</span> <span class="ow">::</span>
  <span class="kt">MonadCond</span> <span class="n">m</span> <span class="ow">=&gt;</span>
  <span class="kt">Population</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span>
  <span class="kt">Population</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>In other words, <code class="docutils literal notranslate"><span class="pre">pushEvidence</span></code> takes a <code class="docutils literal notranslate"><span class="pre">Population</span> <span class="pre">m</span> <span class="pre">a</span></code> where <code class="docutils literal notranslate"><span class="pre">m</span></code> is a <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code> instance. It takes the sum of the weights, divides the weights by it, and then factors by the sum in <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
</section>
<section id="sequential">
<h3>Sequential<a class="headerlink" href="#sequential" title="Permalink to this headline">¶</a></h3>
<p>Summary of key info on <code class="docutils literal notranslate"><span class="pre">Sequential</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Sequential</span> <span class="pre">::</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span> <span class="pre">-&gt;</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadSample</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">instance</span> <span class="pre">MonadSample</span> <span class="pre">(Sequential</span> <span class="pre">m)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadCond</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">instance</span> <span class="pre">MonadCond</span> <span class="pre">(Sequential</span> <span class="pre">m)</span></code></p></li>
</ul>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Sequential</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> 
    <span class="kt">Sequential</span> <span class="p">{</span><span class="n">runSequential</span> <span class="ow">::</span> <span class="kt">Coroutine</span> <span class="p">(</span><span class="kt">Await</span> <span class="nb">()</span><span class="p">)</span> <span class="n">m</span> <span class="n">a</span><span class="p">}</span>
</pre></div>
</div>
<p>This is a wrapper for the <code class="docutils literal notranslate"><span class="pre">Coroutine</span></code> type applied to the <code class="docutils literal notranslate"><span class="pre">Await</span></code> constructor from <code class="docutils literal notranslate"><span class="pre">Control.Monad.Coroutine</span></code>, which is defined thus:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Coroutine</span> <span class="n">s</span> <span class="n">m</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Coroutine</span> <span class="p">{</span>
   <span class="n">resume</span> <span class="ow">::</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="p">(</span><span class="n">s</span> <span class="p">(</span><span class="kt">Coroutine</span> <span class="n">s</span> <span class="n">m</span> <span class="n">r</span><span class="p">))</span> <span class="n">r</span><span class="p">)</span>
   <span class="p">}</span>

<span class="kr">newtype</span> <span class="kt">Await</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Await</span> <span class="p">(</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Unpacking that:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Sequential</span> <span class="n">m</span> <span class="n">a</span> <span class="o">~</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="p">(</span><span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Sequential</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>As usual, <code class="docutils literal notranslate"><span class="pre">m</span></code> is going to be some other probability monad, so understand <code class="docutils literal notranslate"><span class="pre">Sequential</span> <span class="pre">m</span> <span class="pre">a</span></code> as representing a program which, after making a random choice or doing conditioning, we either obtain an <code class="docutils literal notranslate"><span class="pre">a</span></code> value, or a paused computation, which when resumed gets us back to a new <code class="docutils literal notranslate"><span class="pre">Sequential</span> <span class="pre">m</span> <span class="pre">a</span></code>.</p>
<p>(For more on coroutines, see the final article in: https://themonadreader.files.wordpress.com/2011/10/issue19.pdf.)</p>
<p>The monad instance for coroutines is as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">s</span><span class="p">,</span> <span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Coroutine</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
   <span class="n">return</span> <span class="ow">=</span> <span class="n">pure</span>
   <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Coroutine</span> <span class="p">(</span><span class="n">resume</span> <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="n">apply</span> <span class="n">f</span><span class="p">)</span>
      <span class="kr">where</span> <span class="n">apply</span> <span class="n">fc</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">resume</span> <span class="p">(</span><span class="n">fc</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">apply</span> <span class="n">fc</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">(</span><span class="kt">Left</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="n">fc</span><span class="p">)</span> <span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> instance follows from <code class="docutils literal notranslate"><span class="pre">lift</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Coroutine</span> <span class="pre">(Await</span> <span class="pre">())</span> <span class="pre">m</span> <span class="pre">a</span></code>, defined as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">MonadTrans</span> <span class="p">(</span><span class="kt">Coroutine</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
   <span class="n">lift</span> <span class="ow">=</span> <span class="kt">Coroutine</span> <span class="o">.</span> <span class="n">liftM</span> <span class="kt">Right</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code> instance has less trivial content:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Execution is &#39;suspend&#39;ed after each &#39;score&#39;.</span>
<span class="kr">instance</span> <span class="kt">MonadCond</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadCond</span> <span class="p">(</span><span class="kt">Sequential</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">score</span> <span class="n">w</span> <span class="ow">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">score</span> <span class="n">w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">suspend</span>
</pre></div>
</div>
<p>First you take a <code class="docutils literal notranslate"><span class="pre">score</span></code> in the underlying <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code> instance, and then you <code class="docutils literal notranslate"><span class="pre">suspend</span></code>, which means:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | A point where the computation is paused.</span>
<span class="nf">suspend</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Sequential</span> <span class="n">m</span> <span class="nb">()</span>
<span class="nf">suspend</span> <span class="ow">=</span> <span class="kt">Sequential</span> <span class="p">(</span><span class="kt">Coroutine</span> <span class="p">(</span><span class="n">return</span> <span class="p">(</span><span class="kt">Left</span> <span class="p">(</span><span class="kt">Await</span> <span class="n">return</span><span class="p">))))</span>
</pre></div>
</div>
<!-- TODO: double check -->
<p>We can move to the next suspension point with:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">advance</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Sequential</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Sequential</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">advance</span> <span class="ow">=</span> <span class="kt">Sequential</span> <span class="o">.</span> <span class="n">bounce</span> <span class="n">extract</span> <span class="o">.</span> <span class="n">runSequential</span>
</pre></div>
</div>
<p>and move through all with:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Remove the remaining suspension points.</span>
<span class="nf">finish</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Sequential</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">finish</span> <span class="ow">=</span> <span class="n">pogoStick</span> <span class="n">extract</span> <span class="o">.</span> <span class="n">runSequential</span>
</pre></div>
</div>
<p>But most importantly, we can apply a natural transformation over the underlying monad <code class="docutils literal notranslate"><span class="pre">m</span></code> to only the current suspension.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hoistFirst</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="n">m</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Sequential</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Sequential</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">hoistFirst</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Sequential</span> <span class="o">.</span> <span class="kt">Coroutine</span> <span class="o">.</span> <span class="n">f</span> <span class="o">.</span> <span class="n">resume</span> <span class="o">.</span> <span class="n">runSequential</span>
</pre></div>
</div>
<!-- As an example, consider:

TODO: Enumerator example with `trace` -->
<p>When <code class="docutils literal notranslate"><span class="pre">m</span></code> is <code class="docutils literal notranslate"><span class="pre">Population</span> <span class="pre">n</span></code> for some other <code class="docutils literal notranslate"><span class="pre">n</span></code>, then <code class="docutils literal notranslate"><span class="pre">resampleGeneric</span></code> gives us one example of the natural transformation we want. In other words, operating in <code class="docutils literal notranslate"><span class="pre">Sequential</span> <span class="pre">(Population</span> <span class="pre">n)</span></code> works, and not only works but does something statistically interesting: particle filtering (aka SMC).</p>
</section>
<section id="freesampler">
<h3>FreeSampler<a class="headerlink" href="#freesampler" title="Permalink to this headline">¶</a></h3>
<p>Summary of key info on <code class="docutils literal notranslate"><span class="pre">FreeSampler</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FreeSampler</span> <span class="pre">::</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span> <span class="pre">-&gt;</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadSample</span> <span class="pre">(FreeSampler</span> <span class="pre">m)</span></code></p></li>
<li><p><strong>No</strong> instance for <code class="docutils literal notranslate"><span class="pre">MonadCond</span></code></p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">FreeSampler</span> <span class="pre">m</span></code> is not often going to be used on its own, but instead as part of the <code class="docutils literal notranslate"><span class="pre">Traced</span></code> type, defined below. A <code class="docutils literal notranslate"><span class="pre">FreeSampler</span> <span class="pre">m</span> <span class="pre">a</span></code> represents a reified execution of the program.</p>
<p><code class="docutils literal notranslate"><span class="pre">FreeSampler</span> <span class="pre">m</span></code> is best understood if you’re familiar with the standard use of a free monad to construct a domain specific language. For probability in particular, see this <a class="reference external" href="https://jtobin.io/simple-probabilistic-programming">blog post</a>. Here’s the definition:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">SamF</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Random</span> <span class="p">(</span><span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="kr">newtype</span> <span class="kt">FreeSampler</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> 
    <span class="kt">FreeSampler</span> <span class="p">{</span><span class="n">runFreeSampler</span> <span class="ow">::</span> <span class="kt">FT</span> <span class="kt">SamF</span> <span class="n">m</span> <span class="n">a</span><span class="p">}</span>
    
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadSample</span> <span class="p">(</span><span class="kt">FreeSampler</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">random</span> <span class="ow">=</span> <span class="kt">FreeSampler</span> <span class="o">$</span> <span class="n">liftF</span> <span class="p">(</span><span class="kt">Random</span> <span class="n">id</span><span class="p">)</span>
</pre></div>
</div>
<p>The monad-bayes implementation uses a more efficient implementation of <code class="docutils literal notranslate"><span class="pre">FreeT</span></code>, namely <code class="docutils literal notranslate"><span class="pre">FT</span></code> from the <code class="docutils literal notranslate"><span class="pre">free</span></code> package, known as the <em>Church transformed Free monad</em>. This is a technique explained in https://begriffs.com/posts/2016-02-04-difference-lists-and-codennsity.html. But that only changes the operational semantics - performance aside, it works just the same as the standard <code class="docutils literal notranslate"><span class="pre">FreeT</span></code> datatype.</p>
<p>If you unpack the definition, you get:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">FreeSampler</span> <span class="n">m</span> <span class="n">a</span> <span class="o">~</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">FreeSampler</span> <span class="n">m</span> <span class="n">a</span><span class="p">)))</span>
</pre></div>
</div>
<p>As you can see, this is rather like <code class="docutils literal notranslate"><span class="pre">Coroutine</span></code>, except to “resume”, you must provide a new <code class="docutils literal notranslate"><span class="pre">Double</span></code>, corresponding to the value of some particular random choice.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">FreeT</span></code> is a transformer, we can use <code class="docutils literal notranslate"><span class="pre">lift</span></code> to get a <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> instance.</p>
<p>A <em>trace</em> of a program of type <code class="docutils literal notranslate"><span class="pre">MonadSample</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code> is an execution of the program, so a choice for each of the random values. Recall that <code class="docutils literal notranslate"><span class="pre">random</span></code> underlies all of the random values in a program, so a trace for a program is fully specified by a list of <code class="docutils literal notranslate"><span class="pre">Double</span></code>s, giving the value of each call to <code class="docutils literal notranslate"><span class="pre">random</span></code>.</p>
<p>Given a probabilistic program interpreted in <code class="docutils literal notranslate"><span class="pre">FreeSampler</span> <span class="pre">m</span></code>, we can “run” it to produce a program in the underlying monad <code class="docutils literal notranslate"><span class="pre">m</span></code>. For simplicity, consider the case of a program <code class="docutils literal notranslate"><span class="pre">bernoulli</span> <span class="pre">0.5</span> <span class="pre">::</span> <span class="pre">FreeSampler</span> <span class="pre">SamplerIO</span> <span class="pre">Bool</span></code>. We can then use the following function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">withPartialRandomness</span> <span class="ow">::</span> <span class="kt">MonadSample</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">FreeSampler</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="kt">Double</span><span class="p">])</span>
<span class="nf">withPartialRandomness</span> <span class="n">randomness</span> <span class="p">(</span><span class="kt">FreeSampler</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span>
  <span class="n">runWriterT</span> <span class="o">$</span> <span class="n">evalStateT</span> <span class="p">(</span><span class="n">iterTM</span> <span class="n">f</span> <span class="o">$</span> <span class="n">hoistFT</span> <span class="n">lift</span> <span class="n">m</span><span class="p">)</span> <span class="n">randomness</span>
  <span class="kr">where</span>
    <span class="n">f</span> <span class="p">(</span><span class="kt">Random</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
      <span class="c1">-- This block runs in StateT [Double] (WriterT [Double]) m.</span>
      <span class="c1">-- StateT propagates consumed randomness while WriterT records</span>
      <span class="c1">-- randomness used, whether old or new.</span>
      <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">get</span>
      <span class="n">x</span> <span class="ow">&lt;-</span> <span class="kr">case</span> <span class="n">xs</span> <span class="kr">of</span>
        <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="n">random</span>
        <span class="n">y</span> <span class="kt">:</span> <span class="n">ys</span> <span class="ow">-&gt;</span> <span class="n">put</span> <span class="n">ys</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="n">y</span>
      <span class="n">tell</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
      <span class="n">k</span> <span class="n">x</span>
</pre></div>
</div>
<p>This takes a list of <code class="docutils literal notranslate"><span class="pre">Double</span></code>s (a representation of a trace), and a probabilistic program like <code class="docutils literal notranslate"><span class="pre">example</span></code>, and gives back a <code class="docutils literal notranslate"><span class="pre">SamplerIO</span> <span class="pre">(Bool,</span> <span class="pre">[Double])</span></code>. At each call to <code class="docutils literal notranslate"><span class="pre">random</span></code> in <code class="docutils literal notranslate"><span class="pre">example</span></code>, the next double in the list is used. If the list of doubles runs out, calls are made to <code class="docutils literal notranslate"><span class="pre">random</span></code> using the underlying monad, which in our example is <code class="docutils literal notranslate"><span class="pre">SamplerIO</span></code>. Hence “with<em>Partial</em>Randomness”.</p>
<!-- The intuition here is that given a list of doubles in $[0,1]$, you can evaluate any probabilistic program. If your list of numbers is shorter than the number of calls to `random` in the program, the remaining calls are made in the underlying `MonadSample` instance `m`.  -->
<!-- This uses `iterTM`, one of the rather expressive folding patterns in `Control.Monad.Trans.Free` (from the *free* package) and a clever use of the state monad transformer. The upshot is that you supply a  -->
</section>
<section id="traced">
<h3>Traced<a class="headerlink" href="#traced" title="Permalink to this headline">¶</a></h3>
<p>Summary of key info on <code class="docutils literal notranslate"><span class="pre">Traced</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Traced</span> <span class="pre">::</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span> <span class="pre">-&gt;</span> <span class="pre">(Type</span> <span class="pre">-&gt;</span> <span class="pre">Type)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadSample</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">MonadSample</span> <span class="pre">(Traced</span> <span class="pre">m)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadCond</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">MonadCond</span> <span class="pre">(Traced</span> <span class="pre">m)</span></code></p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Traced</span> <span class="pre">m</span></code> is actually several related interpretations, each built on top of <code class="docutils literal notranslate"><span class="pre">FreeSampler</span></code>. These range in complexity.</p>
<!-- Control flow is stochastic in a probabilistic program, which is to say that whether we draw from some variable may depend on a draw from some variable earlier. This means that we don't have a fixed structure like a Bayes net corresponding to a probabilistic program. -->
<p>The reason traces are relevant here is that monad-bayes implements a version of Markov Chain Monte Carlo (MCMC) that operates on arbitrary probabilistic programs often referred to as <em>trace MCMC</em>. The idea is that the MCMC chain takes place on traces of the program. A step constitutes a change to this trace, i.e. to the list of <code class="docutils literal notranslate"><span class="pre">Double</span></code>s. For instance, the algorithm for an MH step goes as follows:</p>
<ul class="simple">
<li><p>propose a new trace by randomly redrawing a single <code class="docutils literal notranslate"><span class="pre">Double</span></code> in the trace</p></li>
<li><p>accept or reject with the MH criterion</p></li>
</ul>
<p>It’s convenient to specify a trace not just as a <code class="docutils literal notranslate"><span class="pre">[Double]</span></code> but also with the resulting output, and the density of that output. This is what monad-bayes does:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Trace</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Trace</span>
  <span class="p">{</span> 
    <span class="n">variables</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Double</span><span class="p">],</span>
    <span class="n">output</span> <span class="ow">::</span> <span class="n">a</span><span class="p">,</span>
    <span class="n">density</span> <span class="ow">::</span> <span class="kt">Log</span> <span class="kt">Double</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>We also need a specification of the probabilistic program in question, free of any particular interpretation. That is precisely what <code class="docutils literal notranslate"><span class="pre">FreeSampler</span></code> is for.</p>
<p>The simplest version of <code class="docutils literal notranslate"><span class="pre">Traced</span></code> is in <code class="docutils literal notranslate"><span class="pre">Control.Monad.Bayes.Traced.Basic</span></code></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Traced</span> <span class="n">m</span> <span class="n">a</span> <span class="o">~</span> <span class="p">(</span><span class="kt">FreeSampler</span> <span class="kt">Identity</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Log</span> <span class="kt">Double</span><span class="p">),</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Trace</span> <span class="n">a</span><span class="p">))</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">Traced</span></code> interpretation of a model is a particular run of the model with its corresponding probability, alongside a distribution over <code class="docutils literal notranslate"><span class="pre">Trace</span></code> info, which records: the value of each call to <code class="docutils literal notranslate"><span class="pre">random</span></code>, the value of the final output, and the density of this program trace.</p>
<p>This machinery allows us to implement MCMC (see inference methods below for details).</p>
</section>
<section id="integrator">
<h3>Integrator<a class="headerlink" href="#integrator" title="Permalink to this headline">¶</a></h3>
<p>Summary of key info:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Integrator</span> <span class="pre">::</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">MonadSample</span> <span class="pre">Integrator</span></code></p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Integrator</span></code> is in <code class="docutils literal notranslate"><span class="pre">Control.Monad.Bayes.Integrator</span></code>, defined as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Integrator</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Integrator</span> <span class="p">{</span><span class="n">getCont</span> <span class="ow">::</span> <span class="kt">Cont</span> <span class="kt">Double</span> <span class="n">a</span><span class="p">}</span>
</pre></div>
</div>
<p>This <code class="docutils literal notranslate"><span class="pre">MonadSample</span></code> instance interprets a probabilistic program as a numerical integrator. For a nice explanation, see <a class="reference external" href="https://jtobin.io/giry-monad-implementation">this blog post</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Integrator</span> <span class="pre">a</span></code> is isomorphic to <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">Double)</span> <span class="pre">-&gt;</span> <span class="pre">Double</span></code>.
A program <code class="docutils literal notranslate"><span class="pre">model</span></code> of type <code class="docutils literal notranslate"><span class="pre">Integrator</span> <span class="pre">a</span></code> will take a function <code class="docutils literal notranslate"><span class="pre">f</span></code> and calculate $E_{p}[f] = \int f(x)*p(x)$ where $p$ is the density of <code class="docutils literal notranslate"><span class="pre">model</span></code>.</p>
<p>The integral for the expectation is performed by quadrature, using the tanh-sinh approach. For example, <code class="docutils literal notranslate"><span class="pre">random</span> <span class="pre">::</span> <span class="pre">Integrator</span> <span class="pre">Double</span></code> is the program which takes a function <code class="docutils literal notranslate"><span class="pre">f</span></code> and integrates <code class="docutils literal notranslate"><span class="pre">f</span></code> over the $(0,1)$ range.</p>
<p>We can calculate the probability for an interval $(a,b)$ of any model of type <code class="docutils literal notranslate"><span class="pre">Integrator</span> <span class="pre">Double</span></code> by setting <code class="docutils literal notranslate"><span class="pre">f</span></code> to be the function that returns $1$ for that range, else $0$. Similarly for the CDF, MGF and so on.</p>
</section>
</section>
<section id="inference-methods-under-the-hood">
<h2>Inference methods under the hood<a class="headerlink" href="#inference-methods-under-the-hood" title="Permalink to this headline">¶</a></h2>
<section id="exact-inference">
<h3>Exact inference<a class="headerlink" href="#exact-inference" title="Permalink to this headline">¶</a></h3>
<p>Exact inference is nothing more than the use of the <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code> instance of <code class="docutils literal notranslate"><span class="pre">MonadInfer</span></code>. It should be noted that this is not a particularly efficient or clever version of exact inference.</p>
<p>For example, consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">example</span> <span class="ow">=</span> <span class="n">replicateM</span> <span class="mi">100</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">bernoulli</span> <span class="mf">0.5</span>
  <span class="n">condition</span> <span class="n">x</span>
  <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>Doing <code class="docutils literal notranslate"><span class="pre">enumerate</span> <span class="pre">example</span></code> will create a list of $2^{100}$ entries, all but one of which have $0$ mass. (See below for a way to perform this inference efficiently).</p>
<p>The main purpose of <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code> is didactic, as a way to understand simple discrete distributions in full. In addition, you can use it in concert with transformers like <code class="docutils literal notranslate"><span class="pre">Weighted</span></code>, to get a sense of how they work. For example, consider:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">example</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">bernoulli</span> <span class="mf">0.5</span>
  <span class="n">condition</span> <span class="n">x</span>
  <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">(enumerate</span> <span class="pre">.</span> <span class="pre">runWeighted)</span> <span class="pre">example</span></code> gives <code class="docutils literal notranslate"><span class="pre">[((False,0.0),0.5),((True,1.0),0.5)]</span></code>. This is quite edifying for understanding <code class="docutils literal notranslate"><span class="pre">(sampleIO</span> <span class="pre">.</span> <span class="pre">runWeighted)</span> <span class="pre">example</span></code>. What it says is that there are precisely two ways the program will run, each with equal probability: either you get <code class="docutils literal notranslate"><span class="pre">False</span></code> with weight <code class="docutils literal notranslate"><span class="pre">0.0</span></code> or <code class="docutils literal notranslate"><span class="pre">True</span></code> with weight <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.</p>
</section>
<section id="quadrature">
<h3>Quadrature<a class="headerlink" href="#quadrature" title="Permalink to this headline">¶</a></h3>
<p>As described on the section on <code class="docutils literal notranslate"><span class="pre">Integrator</span></code>, we can interpret our probabilistic program of type <code class="docutils literal notranslate"><span class="pre">MonadSample</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code> as having concrete type <code class="docutils literal notranslate"><span class="pre">Integrator</span> <span class="pre">a</span></code>. This views our program as an integrator, allowing us to calculate expectations, probabilities and so on via quadrature (i.e. numerical approximation of an integral).</p>
<p>This can also handle programs of type <code class="docutils literal notranslate"><span class="pre">MonadInfer</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code>, that is, programs with <code class="docutils literal notranslate"><span class="pre">factor</span></code> statements. For these cases, a function <code class="docutils literal notranslate"><span class="pre">normalize</span> <span class="pre">::</span> <span class="pre">Weighted</span> <span class="pre">Integrator</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Integrator</span> <span class="pre">a</span></code> is employed. For example,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">model</span> <span class="ow">::</span> <span class="kt">MonadInfer</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="kt">Double</span>
<span class="nf">model</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">var</span> <span class="ow">&lt;-</span> <span class="n">gamma</span> <span class="mi">1</span> <span class="mi">1</span>
  <span class="n">n</span> <span class="ow">&lt;-</span> <span class="n">normal</span> <span class="mi">0</span> <span class="p">(</span><span class="n">sqrt</span> <span class="n">var</span><span class="p">)</span>
  <span class="n">condition</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">return</span> <span class="n">var</span>
</pre></div>
</div>
<p>is really an unnormalized measure, rather than a probability distribution. <code class="docutils literal notranslate"><span class="pre">normalize</span></code> views it as of type <code class="docutils literal notranslate"><span class="pre">Weighted</span> <span class="pre">Integrator</span> <span class="pre">Double</span></code>, which is isomorphic to <code class="docutils literal notranslate"><span class="pre">(Double</span> <span class="pre">-&gt;</span> <span class="pre">(Double,</span> <span class="pre">Log</span> <span class="pre">Double)</span> <span class="pre">-&gt;</span> <span class="pre">Double)</span></code>. This can be used to compute the normalization constant, and divide the integrator’s output by it, all within <code class="docutils literal notranslate"><span class="pre">Integrator</span></code>.</p>
</section>
<section id="independent-forward-sampling">
<h3>Independent forward sampling<a class="headerlink" href="#independent-forward-sampling" title="Permalink to this headline">¶</a></h3>
<p>For any program of type <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">MonadSample</span> <span class="pre">m</span> <span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code>, we may do <code class="docutils literal notranslate"><span class="pre">sampleIO</span> <span class="pre">p</span></code> or <code class="docutils literal notranslate"><span class="pre">sampleSTfixed</span> <span class="pre">p</span></code>. Note that if there are any calls to <code class="docutils literal notranslate"><span class="pre">factor</span></code> in the program, then it cannot have type <code class="docutils literal notranslate"><span class="pre">MonadSample</span> <span class="pre">m</span></code>.</p>
</section>
<section id="independent-weighted-sampling">
<h3>Independent weighted sampling<a class="headerlink" href="#independent-weighted-sampling" title="Permalink to this headline">¶</a></h3>
<p>Consider</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">example</span> <span class="ow">::</span> <span class="kt">MonadInfer</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="kt">Bool</span>
<span class="nf">example</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">bernoulli</span> <span class="mf">0.5</span>
  <span class="n">condition</span> <span class="n">x</span>
  <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">(runWeighted</span> <span class="pre">.</span> <span class="pre">sampleIO)</span> <span class="pre">example</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">(Bool,</span> <span class="pre">Log</span> <span class="pre">Double)</span></code> returns a tuple of a truth value and a probability mass (or more generally density). How does this work? Types are clarifying:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">run</span> <span class="ow">=</span> 
  <span class="p">(</span><span class="n">sampleIO</span> <span class="ow">::</span> <span class="kt">SamplerIO</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span> <span class="kt">Double</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">)</span>
  <span class="o">.</span> <span class="p">(</span><span class="n">runWeighted</span> <span class="ow">::</span>  <span class="kt">Weighted</span> <span class="kt">SamplerIO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">SamplerIO</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span> <span class="kt">Double</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the program is being interpreted in the <code class="docutils literal notranslate"><span class="pre">Weighted</span> <span class="pre">SamplerIO</span></code> instance of <code class="docutils literal notranslate"><span class="pre">MonadInfer</span></code>.</p>
</section>
<section id="metropolis-hastings-mcmc">
<h3>Metropolis Hastings MCMC<a class="headerlink" href="#metropolis-hastings-mcmc" title="Permalink to this headline">¶</a></h3>
<p>The version of MCMC in monad-bayes performs its random walk on program traces of type <code class="docutils literal notranslate"><span class="pre">Trace</span> <span class="pre">a</span></code>. The motivation for doing this is that <strong>any</strong> probabilistic program can then be used with MCMC entirely automatically.</p>
<p>A single step in this chain (in Metropolis Hasting MCMC) looks like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mhTrans</span> <span class="ow">::</span> <span class="kt">MonadSample</span> <span class="n">m</span> <span class="ow">=&gt;</span> 
    <span class="kt">Weighted</span> <span class="p">(</span><span class="kt">FreeSampler</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Trace</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Trace</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">mhTrans</span> <span class="n">m</span> <span class="n">t</span><span class="o">@</span><span class="kt">Trace</span> <span class="p">{</span><span class="n">variables</span> <span class="ow">=</span> <span class="n">us</span><span class="p">,</span> <span class="n">density</span> <span class="ow">=</span> <span class="n">p</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">us</span>
  <span class="n">us&#39;</span> <span class="ow">&lt;-</span> <span class="kr">do</span>
    <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">discrete</span> <span class="o">$</span> <span class="n">discreteUniformAB</span> <span class="mi">0</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u&#39;</span> <span class="ow">&lt;-</span> <span class="n">random</span>
    <span class="kr">case</span> <span class="n">splitAt</span> <span class="n">i</span> <span class="n">us</span> <span class="kr">of</span>
      <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="kr">_</span> <span class="kt">:</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="o">$</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">(</span><span class="n">u&#39;</span> <span class="kt">:</span> <span class="n">ys</span><span class="p">)</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">&quot;impossible&quot;</span>
  <span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">vs</span><span class="p">)</span> <span class="ow">&lt;-</span> 
      <span class="n">runWriterT</span> <span class="o">$</span> <span class="n">runWeighted</span> 
      <span class="o">$</span> <span class="kt">Weighted</span><span class="o">.</span><span class="n">hoist</span> <span class="p">(</span><span class="kt">WriterT</span> <span class="o">.</span> <span class="n">withPartialRandomness</span> <span class="n">us&#39;</span><span class="p">)</span> <span class="n">m</span>
  <span class="kr">let</span> <span class="n">ratio</span> <span class="ow">=</span> <span class="p">(</span><span class="n">exp</span> <span class="o">.</span> <span class="n">ln</span><span class="p">)</span> <span class="o">$</span> <span class="n">min</span> <span class="mi">1</span> 
      <span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">fromIntegral</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">length</span> <span class="n">vs</span><span class="p">)))</span>
  <span class="n">accept</span> <span class="ow">&lt;-</span> <span class="n">bernoulli</span> <span class="n">ratio</span>
  <span class="n">return</span> <span class="o">$</span> <span class="kr">if</span> <span class="n">accept</span> <span class="kr">then</span> <span class="kt">Trace</span> <span class="n">vs</span> <span class="n">b</span> <span class="n">q</span> <span class="kr">else</span> <span class="n">t</span>
</pre></div>
</div>
<p>Our probabilistic program is interpreted in the type <code class="docutils literal notranslate"><span class="pre">Weighted</span> <span class="pre">(FreeSampler</span> <span class="pre">m)</span> <span class="pre">a</span></code>, which is an instance of <code class="docutils literal notranslate"><span class="pre">MonadInfer</span></code>. We use this to define our kernel on traces. We begin by perturbing the list of doubles contained in the trace by selecting a random position in the list and resampling there. We could do this <em>proposal</em> in a variety of ways, but here, we do so by choosing a double from the list at random and resampling it (hence, <em>single site</em> trace MCMC). We then run the program on this new list of doubles; <code class="docutils literal notranslate"><span class="pre">((b,q),</span> <span class="pre">vs)</span></code> is the outcome, probability, and result of all calls to <code class="docutils literal notranslate"><span class="pre">random</span></code>, respectively (recalling that the list of doubles may be shorter than the number of calls to <code class="docutils literal notranslate"><span class="pre">random</span></code>). The value of these is probabilistic in the underlying monad <code class="docutils literal notranslate"><span class="pre">m</span></code>. We then use the MH criterion to decide whether to accept the new list of doubles as our trace.</p>
<p>MH is then easily defined as taking steps with this kernel, in the usual fashion. Note that it works for any probabilistic program whatsoever.</p>
<p><strong>Warning</strong>: the default proposal is single site, meaning that you change one random number in the trace at a time. As a result, the proposal may not be ergodic for models with hard constraints. As a simple example, suppose that you’re doing a random walk, and trying to get from a trace corresponding to the output <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">True)</span></code> to a trace corresponding to <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">False)</span></code>. But if <code class="docutils literal notranslate"><span class="pre">(False,</span> <span class="pre">True)</span></code> and <code class="docutils literal notranslate"><span class="pre">(True,</span> <span class="pre">False)</span></code> have no probability, you have no hope of getting there. <strong>Don’t expect MCMC to be efficient without designing your own proposal, or even correct when the proposal is not ergodic</strong>.</p>
</section>
<section id="sequential-importance-sampling">
<h3>Sequential Importance Sampling<a class="headerlink" href="#sequential-importance-sampling" title="Permalink to this headline">¶</a></h3>
<p>This is provided by</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sis</span> <span class="ow">::</span>
  <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span>
  <span class="c1">-- | transformation</span>
  <span class="p">(</span><span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="n">m</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span>
  <span class="c1">-- | number of time steps</span>
  <span class="kt">Int</span> <span class="ow">-&gt;</span>
  <span class="kt">Sequential</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span>
  <span class="n">m</span> <span class="n">a</span>
<span class="nf">sis</span> <span class="n">f</span> <span class="n">k</span> <span class="ow">=</span> <span class="n">finish</span> <span class="o">.</span> <span class="n">composeCopies</span> <span class="n">k</span> <span class="p">(</span><span class="n">advance</span> <span class="o">.</span> <span class="n">hoistFirst</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>in Control.Monad.Bayes.Sequential. You provide a natural transformation in the underlying monad <code class="docutils literal notranslate"><span class="pre">m</span></code>, and <code class="docutils literal notranslate"><span class="pre">sis</span></code> applies that natural transformation at each point of conditioning in your program. The main use case is in defining <code class="docutils literal notranslate"><span class="pre">smc</span></code>, below, but here is a nice alternative use case:</p>
<p>Consider the program:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">example</span> <span class="ow">=</span> <span class="n">replicateM</span> <span class="mi">100</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">bernoulli</span> <span class="mf">0.5</span>
  <span class="n">condition</span> <span class="n">x</span>
  <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>Naive enumeration, as in <code class="docutils literal notranslate"><span class="pre">enumerate</span> <span class="pre">example</span></code> is enormously and needlessly inefficient, because it will create a $2^{100}$ size list of possible values. What we’d like to do is to throw away values of <code class="docutils literal notranslate"><span class="pre">x</span></code> that are <code class="docutils literal notranslate"><span class="pre">False</span></code> at each condition statement, rather than carrying them along forever.</p>
<p>Suppose we have a function <code class="docutils literal notranslate"><span class="pre">removeZeros</span> <span class="pre">::</span> <span class="pre">Enumerator</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Enumerator</span> <span class="pre">a</span></code>, which removes values of the distribution with $0$ mass from <code class="docutils literal notranslate"><span class="pre">Enumerator</span></code>. We can then write <code class="docutils literal notranslate"><span class="pre">enumerate</span> <span class="pre">$</span> <span class="pre">sis</span> <span class="pre">removeZeros</span> <span class="pre">100</span> <span class="pre">$</span> <span class="pre">model</span></code> to run <code class="docutils literal notranslate"><span class="pre">removeZeros</span></code> at each of the 100 <code class="docutils literal notranslate"><span class="pre">condition</span></code> statements, making the algorithm run quickly.</p>
</section>
<section id="sequential-monte-carlo">
<h3>Sequential Monte Carlo<a class="headerlink" href="#sequential-monte-carlo" title="Permalink to this headline">¶</a></h3>
<p>Sequential importance resampling works by doing <code class="docutils literal notranslate"><span class="pre">sis</span></code> with a resampler of your choice, such as <code class="docutils literal notranslate"><span class="pre">resampleMultinomial</span></code>, after first spawning a set of <code class="docutils literal notranslate"><span class="pre">n</span></code> particles.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sir</span> <span class="ow">::</span>
  <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span>
  <span class="c1">-- | resampler</span>
  <span class="p">(</span><span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="kt">Population</span> <span class="n">m</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Population</span> <span class="n">m</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span>
  <span class="c1">-- | number of timesteps</span>
  <span class="kt">Int</span> <span class="ow">-&gt;</span>
  <span class="c1">-- | population size</span>
  <span class="kt">Int</span> <span class="ow">-&gt;</span>
  <span class="c1">-- | model</span>
  <span class="kt">Sequential</span> <span class="p">(</span><span class="kt">Population</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="ow">-&gt;</span>
  <span class="kt">Population</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">sir</span> <span class="n">resampler</span> <span class="n">k</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">sis</span> <span class="n">resampler</span> <span class="n">k</span> <span class="o">.</span> <span class="kt">Seq</span><span class="o">.</span><span class="n">hoistFirst</span> <span class="p">(</span><span class="n">spawn</span> <span class="n">n</span> <span class="o">&gt;&gt;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="particle-marginal-metropolis-hastings">
<h3>Particle Marginal Metropolis Hastings<a class="headerlink" href="#particle-marginal-metropolis-hastings" title="Permalink to this headline">¶</a></h3>
<p>Quoting the monad-bayes paper:</p>
<p>“PMMH is only applicable to models with a specific structure, namely the probabilistic program needs to decompose to a prior over the global parameters <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">param</span></code> and the rest of the model <code class="docutils literal notranslate"><span class="pre">param</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></code>. Combining these using &gt;&gt;= would yield the complete model of type <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">a</span></code>.”</p>
<p>“The idea is to do MH on the parameters of the model. Recall that for MH we need to compute the likelihood for the particular values of parameters but that involves integrating over the remaining random variables in the model which is intractable. Fortunately to obtain valid MH it is sufficient to have an unbiased estimator for the likelihood which is produced by a single sample from <code class="docutils literal notranslate"><span class="pre">Weighted</span></code>. MH with such an estimator is referred to as pseudo-marginal MH. If instead of taking a single weight from <code class="docutils literal notranslate"><span class="pre">Weighted</span></code> we take the sum of weights from <code class="docutils literal notranslate"><span class="pre">Population</span></code> we obtain an unbiased estimator with lower variance. In particular if such a <code class="docutils literal notranslate"><span class="pre">Population</span></code> is a result of smc the resulting algorithm is known as PMMH.”</p>
<p>Because of the modularity of monad-bayes, the implementation is remarkably simple, and directly linked to the algorithm:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pmmh</span> <span class="n">t</span> <span class="n">k</span> <span class="n">n</span> <span class="n">param</span> <span class="n">model</span> <span class="ow">=</span> <span class="n">mh</span> <span class="n">t</span> 
  <span class="p">(</span><span class="n">param</span> <span class="o">&gt;&gt;=</span> 
    <span class="n">runPopulation</span> 
    <span class="o">.</span> <span class="n">pushEvidence</span> 
    <span class="o">.</span> <span class="kt">Pop</span><span class="o">.</span><span class="n">hoist</span> <span class="n">lift</span> 
    <span class="o">.</span> <span class="n">smcSystematic</span> <span class="n">k</span> <span class="n">n</span> 
    <span class="o">.</span> <span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<p>There’s a lot to unpack here. Here’s the definition with more types. To shorten the signatures, the synonyms: <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">Traced,</span> <span class="pre">S</span> <span class="pre">=</span> <span class="pre">Sequential,</span> <span class="pre">P</span> <span class="pre">=</span> <span class="pre">Population</span></code> are used:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pmmh</span> <span class="ow">::</span>
  <span class="kt">MonadInfer</span> <span class="n">m</span> <span class="ow">=&gt;</span>
  <span class="c1">-- | number of Metropolis-Hastings steps</span>
  <span class="kt">Int</span> <span class="ow">-&gt;</span>
  <span class="c1">-- | number of time steps</span>
  <span class="kt">Int</span> <span class="ow">-&gt;</span>
  <span class="c1">-- | number of particles</span>
  <span class="kt">Int</span> <span class="ow">-&gt;</span>
  <span class="c1">-- | model parameters prior</span>
  <span class="kt">T</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span>
  <span class="c1">-- | model</span>
  <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">P</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span>
  <span class="n">m</span> <span class="p">[[(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span> <span class="kt">Double</span><span class="p">)]]</span>
<span class="nf">pmmh</span> <span class="n">t</span> <span class="n">k</span> <span class="n">n</span> <span class="n">param</span> <span class="n">model</span> <span class="ow">=</span>
  <span class="p">(</span><span class="n">mh</span> <span class="n">t</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">m</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span> <span class="kt">Double</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">[[(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span> <span class="kt">Double</span><span class="p">)]])</span>
  <span class="p">((</span><span class="n">param</span> <span class="ow">::</span> <span class="kt">T</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> 
      <span class="p">(</span><span class="n">runPopulation</span> <span class="ow">::</span> <span class="kt">P</span> <span class="p">(</span><span class="kt">T</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">m</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Log</span> <span class="kt">Double</span><span class="p">)])</span> 
      <span class="o">.</span> <span class="p">(</span><span class="n">pushEvidence</span> <span class="ow">::</span> <span class="kt">P</span> <span class="p">(</span><span class="kt">T</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">P</span> <span class="p">(</span><span class="kt">T</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> 
      <span class="o">.</span> <span class="kt">Pop</span><span class="o">.</span><span class="n">hoist</span> <span class="p">(</span><span class="n">lift</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">x</span><span class="o">.</span> <span class="n">m</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="n">m</span> <span class="n">x</span><span class="p">)</span> 
      <span class="o">.</span> <span class="p">(</span><span class="n">smcSystematic</span> <span class="n">k</span> <span class="n">n</span> <span class="ow">::</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">P</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">P</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span> 
      <span class="o">.</span> <span class="p">(</span><span class="n">model</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">P</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span><span class="p">))</span>
</pre></div>
</div>
<p>(Note that this uses the version of <code class="docutils literal notranslate"><span class="pre">mh</span></code> from <code class="docutils literal notranslate"><span class="pre">Control.Monad.Bayes.Traced.Static</span></code>.)</p>
<p>To understand this, note that the outer algorithm is just <code class="docutils literal notranslate"><span class="pre">mh</span></code>. But the probabilistic program that we pass to <code class="docutils literal notranslate"><span class="pre">mh</span></code> does the following: run <code class="docutils literal notranslate"><span class="pre">param</span></code> to get values for the parameters and then pass these to <code class="docutils literal notranslate"><span class="pre">model</span></code>. Then run <code class="docutils literal notranslate"><span class="pre">n</span></code> steps of SMC with <code class="docutils literal notranslate"><span class="pre">k</span></code> particles. Then lift the underlying monad <code class="docutils literal notranslate"><span class="pre">m</span></code> into <code class="docutils literal notranslate"><span class="pre">Traced</span> <span class="pre">m</span></code>. Then calculate the sum of the weights of the particles and <code class="docutils literal notranslate"><span class="pre">factor</span></code> on this (this is what <code class="docutils literal notranslate"><span class="pre">pushEvidence</span></code> does). This <code class="docutils literal notranslate"><span class="pre">factor</span></code> takes place in <code class="docutils literal notranslate"><span class="pre">Traced</span> <span class="pre">m</span></code>, so it is “visible” to <code class="docutils literal notranslate"><span class="pre">mh</span></code>.</p>
</section>
<section id="resample-move-sequential-monte-carlo">
<h3>Resample-Move Sequential Monte Carlo<a class="headerlink" href="#resample-move-sequential-monte-carlo" title="Permalink to this headline">¶</a></h3>
<!-- This is pretty complicated to think about, but again, the key is to think smart, not hard, and rely on the modularity of the architecture.  -->
<p>The paper introducing monad-bayes has this to say about resample-move SMC:</p>
<p>“A common problem with particle filters is that of particle degeneracy, where after resampling many particles are the same, effectively reducing the sample size. One way to ameliorate this problem is to introduce rejuvenation moves, where after each resampling we apply a number of MCMC transitions to each particle independently, thus spreading them around the space. If we use an MCMC kernel that preserves the target distribution at a given step, the resulting algorithm is correct”</p>
<p>monad-bayes provides three versions of RMSMC, each of which uses one of the three <code class="docutils literal notranslate"><span class="pre">Traced</span></code> implementations respectively. Here is the simplest, which I have annotated with types. To shorten the signatures, the synonyms: <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">=</span> <span class="pre">Traced,</span> <span class="pre">S</span> <span class="pre">=</span> <span class="pre">Sequential,</span> <span class="pre">P</span> <span class="pre">=</span> <span class="pre">Population</span></code> are used:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">rmsmcBasic</span> <span class="ow">::</span>
  <span class="kt">MonadSample</span> <span class="n">m</span> <span class="ow">=&gt;</span>
  <span class="c1">-- | number of timesteps</span>
  <span class="kt">Int</span> <span class="ow">-&gt;</span>
  <span class="c1">-- | number of particles</span>
  <span class="kt">Int</span> <span class="ow">-&gt;</span>
  <span class="c1">-- | number of Metropolis-Hastings transitions after each resampling</span>
  <span class="kt">Int</span> <span class="ow">-&gt;</span>
  <span class="c1">-- | model</span>
  <span class="kt">S</span> <span class="p">(</span><span class="kt">TrBas</span><span class="o">.</span><span class="kt">T</span> <span class="p">(</span><span class="kt">P</span> <span class="n">m</span><span class="p">))</span> <span class="n">a</span> <span class="ow">-&gt;</span>
  <span class="kt">P</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">rmsmcBasic</span> <span class="n">k</span> <span class="n">n</span> <span class="n">t</span> <span class="ow">=</span>
  <span class="p">(</span><span class="kt">TrBas</span><span class="o">.</span><span class="n">marginal</span> <span class="ow">::</span> <span class="kt">T</span> <span class="p">(</span><span class="kt">P</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">P</span> <span class="n">m</span> <span class="n">a</span> <span class="p">)</span>
  <span class="o">.</span> <span class="n">sis</span> 
      <span class="p">(</span>
      <span class="p">(</span><span class="n">composeCopies</span> <span class="n">t</span> <span class="kt">TrBas</span><span class="o">.</span><span class="n">mhStep</span> <span class="ow">::</span> <span class="kt">T</span> <span class="p">(</span><span class="kt">P</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">T</span> <span class="p">(</span><span class="kt">P</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="p">)</span>
      <span class="o">.</span> <span class="kt">TrBas</span><span class="o">.</span><span class="n">hoistT</span> <span class="p">(</span><span class="n">resampleSystematic</span> <span class="ow">::</span> <span class="kt">P</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">P</span> <span class="n">m</span> <span class="n">a</span> <span class="p">)</span> <span class="p">)</span> 
      <span class="n">k</span>
  <span class="o">.</span> <span class="p">(</span><span class="n">hoistS</span> <span class="p">(</span><span class="kt">TrBas</span><span class="o">.</span><span class="n">hoistT</span> <span class="p">(</span><span class="n">spawn</span> <span class="n">n</span> <span class="o">&gt;&gt;</span><span class="p">))</span> <span class="ow">::</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">T</span> <span class="p">(</span><span class="kt">P</span> <span class="n">m</span><span class="p">))</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">T</span> <span class="p">(</span><span class="kt">P</span> <span class="n">m</span><span class="p">))</span> <span class="n">a</span> <span class="p">))</span>
</pre></div>
</div>
<p>What is this doing? Recall that <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">m</span> <span class="pre">a</span></code> represents an <code class="docutils literal notranslate"><span class="pre">m</span></code> of coroutines over <code class="docutils literal notranslate"><span class="pre">a</span></code>. Recall that <code class="docutils literal notranslate"><span class="pre">Traced</span> <span class="pre">m</span> <span class="pre">a</span></code> represents an <code class="docutils literal notranslate"><span class="pre">m</span></code> of  traced computations of <code class="docutils literal notranslate"><span class="pre">a</span></code>. Recall that <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">m</span> <span class="pre">a</span></code> represents an <code class="docutils literal notranslate"><span class="pre">m</span></code> of a list of <code class="docutils literal notranslate"><span class="pre">a</span></code>s.</p>
<p>This means that an <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">(T</span> <span class="pre">(P</span> <span class="pre">m))</span> <span class="pre">a</span></code> is a program “interpreted as a population of traced coroutines”. The paper adds that this “allows us to apply MH transitions to partially executed coroutines, which is exactly what we require for the rejuvenation steps.”</p>
<p>So the algorithm works by creating <code class="docutils literal notranslate"><span class="pre">n</span></code> particles, and at each of the first <code class="docutils literal notranslate"><span class="pre">k</span></code> calls to <code class="docutils literal notranslate"><span class="pre">factor</span></code>, first resampling the population and then for each particle in the population, doing an MH-MCMC walk for <code class="docutils literal notranslate"><span class="pre">t</span></code> steps to update it.</p>
</section>
<section id="sequential-monte-carlo-squared-smc-2">
<h3>Sequential Monte Carlo squared ($SMC^2$)<a class="headerlink" href="#sequential-monte-carlo-squared-smc-2" title="Permalink to this headline">¶</a></h3>
<p>This combines RMSMC and PMMH. That is, it is RMSMC, but for the MCMC rejuvenation procedure, PMMH is used instead of MH.</p>
<p>There is one slight complication here, related to the fact that the MTL style effect system approach requires newtypes when more than one of a given effect appears in a stack, in order to differentiate them.</p>
<!-- todo: finish -->
<!-- ## Cheat Sheet


Basic instances of `MonadSample`:
- `SamplerIO`
- `Traced m`
- `Sequential m`

Basic instances of `MonadCond`:
- `Weighted m`
- `Sequential m`

Basic instances of `MonadInfer`:
- `Enumerator` (discrete distributions only)

Composed instances of `MonadInfer`:

- `Weighted SamplerIO` (used in weighted sampling)
- `Traced (Weighted SamplerIO)` (used in MCMC)
- `Sequential (Population (Weighted SamplerIO)` (used in SMC)
-  more -->
</section>
</section>
</section>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="probprog.html" class="btn btn-neutral" title="User Guide" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Adam Scibior.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> and ❤️  using a custom <a href="https://github.com/LinxiFan/Sphinx-theme">theme</a> based on <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/documentation_options.js"></script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>